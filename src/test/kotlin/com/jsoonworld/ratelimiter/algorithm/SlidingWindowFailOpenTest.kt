package com.jsoonworld.ratelimiter.algorithm

import com.jsoonworld.ratelimiter.config.RateLimiterProperties
import com.jsoonworld.ratelimiter.model.RateLimitAlgorithm
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.runBlocking
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.data.redis.RedisConnectionFailureException
import org.springframework.data.redis.core.ReactiveStringRedisTemplate
import org.springframework.data.redis.core.script.RedisScript
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class SlidingWindowFailOpenTest {

    private lateinit var redisTemplate: ReactiveStringRedisTemplate
    private lateinit var rateLimiter: SlidingWindowRateLimiter

    @BeforeEach
    fun setUp() {
        redisTemplate = mockk()
        val properties = RateLimiterProperties(
            algorithm = RateLimitAlgorithm.SLIDING_WINDOW_LOG,
            capacity = 100,
            refillRate = 10,
            windowSize = 60
        )
        rateLimiter = SlidingWindowRateLimiter(redisTemplate, properties)
    }

    @Test
    fun `should allow request when Redis connection fails on tryAcquire`() {
        runBlocking {
            // Given
            val key = "test-key"
            every {
                redisTemplate.execute(any<RedisScript<List<*>>>(), any<List<String>>(), any<List<String>>())
            } returns Flux.error(RedisConnectionFailureException("Connection refused"))

            // When
            val result = rateLimiter.tryAcquire(key)

            // Then - fail-open policy should allow the request
            assertThat(result.allowed).isTrue()
            assertThat(result.remainingTokens).isEqualTo(100)
            assertThat(result.resetTimeSeconds).isEqualTo(0)
        }
    }

    @Test
    fun `should return maxRequests when Redis connection fails on getRemainingLimit`() {
        runBlocking {
            // Given
            val key = "test-key"
            every {
                redisTemplate.execute(any<RedisScript<Long>>(), any<List<String>>(), any<List<String>>())
            } returns Flux.error(RedisConnectionFailureException("Connection refused"))

            // When
            val remaining = rateLimiter.getRemainingLimit(key)

            // Then - fail-open policy should return maxRequests
            assertThat(remaining).isEqualTo(100)
        }
    }

    @Test
    fun `should not throw when Redis connection fails on reset`() {
        runBlocking {
            // Given
            val key = "test-key"
            every { redisTemplate.delete(any<String>()) } returns Mono.error(
                RedisConnectionFailureException("Connection refused")
            )

            // When & Then - should not throw, fail-open policy applies
            rateLimiter.reset(key)
            // Test passes if no exception is thrown
        }
    }

    @Test
    fun `should allow request when Redis throws generic RedisException on tryAcquire`() {
        runBlocking {
            // Given
            val key = "test-key"
            every {
                redisTemplate.execute(any<RedisScript<List<*>>>(), any<List<String>>(), any<List<String>>())
            } returns Flux.error(io.lettuce.core.RedisException("Redis error"))

            // When
            val result = rateLimiter.tryAcquire(key)

            // Then - fail-open policy should allow the request
            assertThat(result.allowed).isTrue()
            assertThat(result.remainingTokens).isEqualTo(100)
        }
    }

    @Test
    fun `should return maxRequests when Redis throws generic RedisException on getRemainingLimit`() {
        runBlocking {
            // Given
            val key = "test-key"
            every {
                redisTemplate.execute(any<RedisScript<Long>>(), any<List<String>>(), any<List<String>>())
            } returns Flux.error(io.lettuce.core.RedisException("Redis error"))

            // When
            val remaining = rateLimiter.getRemainingLimit(key)

            // Then - fail-open policy should return maxRequests
            assertThat(remaining).isEqualTo(100)
        }
    }

    @Test
    fun `should not throw when Redis throws generic RedisException on reset`() {
        runBlocking {
            // Given
            val key = "test-key"
            every { redisTemplate.delete(any<String>()) } returns Mono.error(
                io.lettuce.core.RedisException("Redis error")
            )

            // When & Then - should not throw, fail-open policy applies
            rateLimiter.reset(key)
            // Test passes if no exception is thrown
        }
    }

    @Test
    fun `should allow request with multiple permits when Redis connection fails`() {
        runBlocking {
            // Given
            val key = "test-key"
            every {
                redisTemplate.execute(any<RedisScript<List<*>>>(), any<List<String>>(), any<List<String>>())
            } returns Flux.error(RedisConnectionFailureException("Connection refused"))

            // When
            val result = rateLimiter.tryAcquire(key, permits = 10)

            // Then - fail-open policy should allow the request
            assertThat(result.allowed).isTrue()
            assertThat(result.remainingTokens).isEqualTo(100)
        }
    }
}
